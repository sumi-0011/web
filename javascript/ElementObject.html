<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Element객체</title>
</head>

<body>
    <h1 style="background-color: blueviolet;">Element객체</h1>
    <h2>소개</h2>
    Element객체는 엘리먼트를 추상화한 객체이다. HTMLElement 객체와의 관계를 이해하기 위해서는 DOM의 취지에 대한 이해가 선행되어야 한다.
    DOM은 HTMl만을 제어하기 위한 모델이 아니다. HTML이나 XML, SVG, XUL과 같이 마크업 형태의 언어를 제어하기 위한 규격이기 때문에 Element는 마크업 언어의 일반적인 규격에 대한 속성을
    정의하고 있고, 각각의 구체적인 언어를 위한 기능은 HTMLElement, SVGElement, XULElement와 같은 객체들을 통해서 추가해서 사용하고 있다.
    <h2>다른 객제들과의 관계</h2>
    DOM의 계층구조에서 Element 객체의 위치는 아래와 같다.
    <img src="https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2240.png" alt="">
    <h2>주요기능</h2>
    <h3>식별자</h3>
    문서내에서 특정한 엘리먼트를 식별하기 위한 용도로 사용되는 API
    <ul>
        <li>Element.classList</li>
        <li>Element.className</li>
        <li>Element.id</li>
        <li>Element.tagName</li>
    </ul>
    <h3>조회</h3>
    엘리먼트의 하위 엘리먼트를 조회하는 API
    <ul>
        <li>Element.getElementsByClassName</li>
        <li>Element.getElementsByTagName</li>
        <li>Element.querySelector</li>
        <li>Element.querySelectorAll</li>
    </ul>
    <h3>속성</h3>
    엘리먼트의 속성을 알아내고 변경하는 API
    <ul>
        <li>Element.getAttribute(name)</li>
        <li>Element.setAttribute(name.value)</li>
        <li>Element.hasAttribute(name)</li>
        <li>Element.removeAttribute(name)</li>
    </ul>

    <h1 style="background-color: blueviolet;">식별자 API</h1>
    엘리먼트를 제어하기 위해서는 그 엘리먼트를 조회하기 위한 식별자가 필요하다.
    본 수업에서는 식별자 API들에 대해서 알아보자.
    <br>HTMl에서 엘리먼트의 이름과 id그리고 class는 식별자로 사용된다. 식별자 API는 이 식별자를 가져오고 변경하는 역할을 한다.
    <h2>Element.tagName</h2>
    해당 엘리먼트의 태그 이름을 알아낸다. 태그 이름을 변경하지는 못한다.
    <p>
    <ul>
        <li>html</li>
        <li>css</li>
        <li id="active" class="important current">JavaScript</li>
    </ul>
    <script>
        console.log(document.getElementById('active').tagName);
    </script>
    </p>
    <h2>Element.id</h2>
    문서에서 id는 단 하나만 등장할 수 있는 식별자이다. 아래 예제는 id의 값을 읽고 변경하는 방법을 보여준다.
    <SCript>
        var active = document.getElementById('active');
        console.log(active.id);
        active.id = 'deactive';
        console.log(active.id);
    </SCript>
    <h2>Element.className </h2>
    클래스는 열개의 엘리먼트를 그룹필 할때 사용한다.
    클래스를 추가할때는 아래와 같이 문자열을 더한다.
    <pre>active.className += " readed"</pre>
    <h2>Element.classList</h2>
    className에 비해서 훨씬 편리한 사용성을 제공한다.
    <script>
        function loop() {
            for (var i = 0; i < active.classList.length; i++) {
                console.log(i, active.classList[i]);
            }
        }
         //클래스를 추가
    </script>
    <br>
    <input type="button" value="DOMTokenList" onclick="console.log(active.classList);" />
    <input type="button" value="조회" onclick="loop();" />
    <input type="button" value="추가" onclick="active.classList.add('marked');" />
    <input type="button" value="제거" onclick="active.classList.remove('important');" />
    <input type="button" value="토글" onclick="active.classList.toggle('current');" />



    <h1 style="background-color: blueviolet;">조회 API</h1>
    <ul>
        <li class="marked">html</li>
        <li>css</li>
        <li id="active1">JavaScript
            <ul>
                <li>JavaScript Core</li>
                <li class="marked">DOM</li>
                <li class="marked">BOM</li>
            </ul>
        </li>
    </ul>
    <script>
        var list = document.getElementsByClassName('marked');
        console.group('document');
        for (var i = 0; i < list.length; i++) {
            console.log(list[i].textContent);
        }
        console.groupEnd();

        console.group('active1');
        var active = document.getElementById('active1');
        var list = active.getElementsByClassName('marked');
        for (var i = 0; i < list.length; i++) {
            console.log(list[i].textContent);
        }
        console.groupEnd();


    </script>
    <h1 style="background-color: blueviolet;">속성 API</h1>
    속성은 Html에서 태그명만으로 부족한 부가적인 정보라고 할 수 있다. 이 속성을 어떨게 제어하는 가 알아보자. <br>
    속성을 제어하는 API는 아래와 같다. 각각의 기능은 이름을 통해서 충분히 유추할 수 있을 것이다.
    <ul>
        <li>Element.getArrtibute(name)</li>
        <li>Element.setAttribute(name,value)</li>
        <li>Element.hasAttribute(name)</li>
        <li>Element.removeAttribute(name)</li>
    </ul>
    <a id="target" href="http://opentutorials.org/">opentutorials</a>
    <script>
        var t = document.getElementById('target');
        console.log(t.getAttribute('href'));
        t.setAttribute('title', 'opentutorials.org');  //title속성의 값을 설정
        console.log(t.hasAttribute('title'));         //title속성의 존재여부
        t.removeAttribute('title');                   //tltme속성 제거
        console.log(t.hasAttributeI('title'));
    </script>

    <h2>속성과 프로퍼티</h2>
    모든 엘리먼트의 (HTML)속성은 (JavaScript객체의)속성과 프로퍼티로 제어가 가능하다.
    <p id="target2">
        Hello world
    </p>
    <script>
        vat target = document.getElementById('target');
        //attribute 방식
        target.setAttribute('class', 'important');
        //property방식
        target.className = 'important';
    </script>
    setAttribute('class','important')와 className = 'important'는 같은 결과를만든다. <br>
    하지만 전자는 attribute방식(속성이라고 부르겠다.)이고 후자는 property방식이다. property방식은 좀 더 간편하고 속도도 빠르지만, 실제 html속성의 이름과 다른 이름을 갖는 경우가 있다.
    그것은 자바 스크립트의 이름 규칙때문이다.
    <br>
    <table>
        <tbody>
            <tr>
                <td>class</td>
                <td>className</td>
            </tr>
            <tr>
                <td>readonly</td>
                <td>readonly</td>
            </tr>
            <tr>
                <td>rowspan</td>
                <td>rowSpan</td>
            </tr>
            <tr>
                <td>colspan</td>
                <td>colspan</td>
            </tr>
            <tr>
                <td>usemap</td>
                <td>userMap</td>
            </tr>
            <tr>
                <td>frameborder</td>
                <td>frameborder</td>
            </tr>
            <tr>
                <td>for</td>
                <td>htmlFor</td>
            </tr>
            <tr>
                <td>maxlength</td>
                <td>maxLength</td>
            </tr>
        </tbody>
    </table>
    <br>
    심지어 속성과 프로퍼티는 값이 다를수도 있다. 아래 코드를 실행한 결과는 속성과 프로퍼치의 값이 꼭 같은 것은 아니라는 것을 보여준다.

    <a id="target" href="./demo1.html">ot</a>
    <script>
        //현재 웹페이지가 http://localhost/webjs/Element/attribute_api/demo3.html 일 때 
        var target = document.getElementById('target');
        // http://localhost/webjs/Element/attribute_api/demo1.html 
        console.log('target.href', target.href);
        // ./demo1.html 
        console.log('target.getAttribute("href")', target.getAttribute("href"));
    </script>
    <h1 style="background-color: blueviolet;">JQuery 속성 제어 API</h1>
    <h2>속성 제어</h2>
    JQuery객체의 메소드 중 setAttribute, getArrtibute에 대응되는 메소드는 attr이다. 또한 removeAttribute에 대응되는 메소드로는 removeAttr이 있다.
    <a href="https://opentutorials.org/" id="target2">opentutorials</a>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script>
        var t = $('#target2');
        console.log(t.attr('href'));
        t.attr('title', 'opentutorials.org');    //title 속성의 값을 설정한다.
        t.removeAttr('title');                  //title 속성을 제거한다. 
    </script>
    <h2>attribute와 property</h2>
    DOM과 마찬가지로 jquery도 속성과 프로퍼티를 구분한다. 속성은 attr, 프로퍼티는 prop 메소드를 사용한다.
    <a href="./demo.html" id="t1">opentutorials</a>
    <input type="checkbox" id="target2" checked="checked" />
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script>
        //현재 문서의 URL이 아래와 같다고 했을때 
        //http://localhost/jQuery_attribute_api/demo2.html
        var t1 = $('#t1');
        console.log(t1.attr('href'));   //./demo.html
        console.log(t1.prop('href'));   //http://localhost/jQuery_attribute_api/demo2.html

        var t2 = $('#t2');
        console.log(t2.attr('checked'));
        console.log(t2.prop('checked'));
    </script>
    jquery을 이용하면 프로퍼티의 이름으로 어떤것을 사용하던 올바름 것으로 교정해준다. 이런것이 라이브러리를 사용하는 의의라고 할수있다.
    <br>
    <div id="t1">opentutorials</div>
    <div id="t2">opentutorials</div>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script>
        $('#t1').prop('className', 'important');
        $('#t2').prop('class', 'current');  
    </script>
    <p>
        $('#target') 자체는 jQuery객체를 리턴합니다. (유사배열이라고 합니다) <br>
        리턴한 객체의 요소, $('#target')[0] 과 같은 놈들이 DOM 객체입니다.
    </p>

    <h1 style="background-color: blueviolet;">jquery 조회 범위 제한</h1>
    이전 수업에서 Element 객체에서 getElementBy* 메소드를 실행하면 조회의 범위가 그 객체의 하위 엘리먼트로 제한된다는 것을 알아봤다. jquery에서는 어떻게 이러한 작업을 할 수 있을까?
    <h2>selector context</h2>
    가장 간편한 방법은 조회할 때 조회 범위를 제한하는 것이다. 그 제한된 범위를 jquery에서는 selector context라고 한다.
    <ul>
        <li class="marked3">html</li>
        <li>css</li>
        <li id="active3">JavaScript
            <ul>
                <li>JavaScript</li>
                <li class="marked3">DOM</li>    
                <li class="marked3">BOM</li>
            </ul>
        </li>
    </ul>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script>
        $(".marked3","#active").css("background-color","red");
        //$( "#active .marked").css( "background-color", "red" );
    </script>
    <h2>.find()</h2>
    find는 jquery 객체 내에서 엘리먼트를 조회하는 기능을 제공한다. 아래의 코드는 위의 예제와 효과가 같다.
    <pre>$( "#active").find('.marked').css( "background-color", "red" );</pre>
    find를 쓰는 이유는 체인을 끊지 않고 작업의 대상을 변경하고 싶을떄 사용한다. 기본 예제를 아래와 같이 변경해보자 

    <pre>$('#active').css('color','blue').find('.marked').css( "background-color", "red" );</pre>   
    <p>즉 li.item-li 엘리먼트에 해당하는 모든 엘리먼트의 전경색을 파란색으로 변경한 후에 li 엘리먼트만을 조회해서 배경색을 붉은색으로 지정하고 있다. </p>
    
</body>

</html>